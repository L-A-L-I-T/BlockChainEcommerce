{"ast":null,"code":"/* eslint-disable no-undef */\n'use strict';\n\nconst fetch = require('node-fetch');\n\nconst merge = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst {\n  URL,\n  URLSearchParams\n} = require('iso-url');\n\nconst TextDecoder = require('./text-decoder');\n\nconst AbortController = require('abort-controller');\n\nconst anySignal = require('any-signal');\n\nconst Request = fetch.Request;\nconst Headers = fetch.Headers;\n\nclass TimeoutError extends Error {\n  constructor() {\n    super('Request timed out');\n    this.name = 'TimeoutError';\n  }\n\n}\n\nclass HTTPError extends Error {\n  constructor(response) {\n    super(response.statusText);\n    this.name = 'HTTPError';\n    this.response = response;\n  }\n\n}\n\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise;\n  }\n\n  const start = Date.now();\n\n  const timedOut = () => {\n    const time = Date.now() - start;\n    return time >= ms;\n  };\n\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError());\n        abortController.abort();\n      }\n    }, ms);\n\n    const after = next => {\n      return res => {\n        clearTimeout(timeoutID);\n\n        if (timedOut()) {\n          reject(new TimeoutError());\n          return;\n        }\n\n        next(res);\n      };\n    };\n\n    promise.then(after(resolve), after(reject));\n  });\n};\n\nconst defaults = {\n  headers: {},\n  throwHttpErrors: true,\n  credentials: 'same-origin',\n  transformSearchParams: p => p\n};\n/**\n * @typedef {Object} APIOptions - creates a new type named 'SpecialType'\n * @prop {any} [body] - Request body\n * @prop {Object} [json] - JSON shortcut\n * @prop {string} [method] - GET, POST, PUT, DELETE, etc.\n * @prop {string} [base] - The base URL to use in case url is a relative URL\n * @prop {Headers|Record<string, string>} [headers] - Request header.\n * @prop {number} [timeout] - Amount of time until request should timeout in ms.\n * @prop {AbortSignal} [signal] - Signal to abort the request.\n * @prop {URLSearchParams|Object} [searchParams] - URL search param.\n * @prop {string} [credentials]\n * @prop {boolean} [throwHttpErrors]\n * @prop {function(URLSearchParams): URLSearchParams } [transformSearchParams]\n * @prop {function(any): any} [transform] - When iterating the response body, transform each chunk with this function.\n * @prop {function(Response): Promise<void>} [handleError] - Handle errors\n */\n\nclass HTTP {\n  /**\n   *\n   * @param {APIOptions} options\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /** @type {APIOptions} */\n    this.opts = merge(defaults, options);\n  }\n  /**\n   * Fetch\n   *\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  async fetch(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /** @type {APIOptions} */\n    const opts = merge(this.opts, options);\n    opts.headers = new Headers(opts.headers); // validate resource type\n\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request');\n    } // validate resource format and normalize with prefixUrl\n\n\n    if (opts.base && typeof opts.base === 'string' && typeof resource === 'string') {\n      if (resource.startsWith('/')) {\n        throw new Error('`resource` must not begin with a slash when using `base`');\n      }\n\n      if (!opts.base.endsWith('/')) {\n        opts.base += '/';\n      }\n\n      resource = opts.base + resource;\n    } // TODO: try to remove the logic above or fix URL instance input without trailing '/'\n\n\n    const url = new URL(resource, opts.base);\n\n    if (opts.searchParams) {\n      url.search = opts.transformSearchParams(new URLSearchParams(opts.searchParams));\n    }\n\n    if (opts.json !== undefined) {\n      opts.body = JSON.stringify(opts.json);\n      opts.headers.set('content-type', 'application/json');\n    }\n\n    const abortController = new AbortController();\n    const signal = anySignal([abortController.signal, opts.signal]);\n    const response = await timeout(fetch(url, { ...opts,\n      signal,\n      timeout: undefined\n    }), opts.timeout, abortController);\n\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response);\n      }\n\n      throw new HTTPError(response);\n    }\n\n    response.iterator = function () {\n      const it = streamToAsyncIterator(response.body);\n\n      if (!isAsyncIterator(it)) {\n        throw new Error('Can\\'t convert fetch body into a Async Iterator:');\n      }\n\n      return it;\n    };\n\n    response.ndjson = async function* () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk);\n        } else {\n          yield chunk;\n        }\n      }\n    };\n\n    return response;\n  }\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  post(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, { ...options,\n      method: 'POST'\n    });\n  }\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  get(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, { ...options,\n      method: 'GET'\n    });\n  }\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  put(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, { ...options,\n      method: 'PUT'\n    });\n  }\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  delete(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, { ...options,\n      method: 'DELETE'\n    });\n  }\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  options(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, { ...options,\n      method: 'OPTIONS'\n    });\n  }\n\n}\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncGenerator<Uint8Array, void, any>} source\n * @returns {AsyncGenerator<Object, void, any>}\n */\n\n\nconst ndjson = async function* (source) {\n  const decoder = new TextDecoder();\n  let buf = '';\n\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, {\n      stream: true\n    });\n    const lines = buf.split(/\\r?\\n/);\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim();\n\n      if (l.length > 0) {\n        yield JSON.parse(l);\n      }\n    }\n\n    buf = lines[lines.length - 1];\n  }\n\n  buf += decoder.decode();\n  buf = buf.trim();\n\n  if (buf.length !== 0) {\n    yield JSON.parse(buf);\n  }\n};\n\nconst streamToAsyncIterator = function (source) {\n  if (isAsyncIterator(source)) {\n    // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n    if (Object.prototype.hasOwnProperty.call(source, 'readable') && Object.prototype.hasOwnProperty.call(source, 'writable')) {\n      const iter = source[Symbol.asyncIterator]();\n      const wrapper = {\n        next: iter.next.bind(iter),\n        return: () => {\n          source.destroy();\n          return iter.return();\n        },\n        [Symbol.asyncIterator]: () => {\n          return wrapper;\n        }\n      };\n      return wrapper;\n    }\n\n    return source;\n  }\n\n  const reader = source.getReader();\n  return {\n    next() {\n      return reader.read();\n    },\n\n    return() {\n      reader.releaseLock();\n      return {};\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n};\n\nconst isAsyncIterator = obj => {\n  return typeof obj === 'object' && obj !== null && // typeof obj.next === 'function' &&\n  typeof obj[Symbol.asyncIterator] === 'function';\n};\n\nHTTP.HTTPError = HTTPError;\nHTTP.TimeoutError = TimeoutError;\nHTTP.streamToAsyncIterator = streamToAsyncIterator;\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options);\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options);\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options);\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options);\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options);\n\nmodule.exports = HTTP;","map":{"version":3,"names":["fetch","require","merge","bind","ignoreUndefined","URL","URLSearchParams","TextDecoder","AbortController","anySignal","Request","Headers","TimeoutError","Error","constructor","name","HTTPError","response","statusText","timeout","promise","ms","abortController","undefined","start","Date","now","timedOut","time","Promise","resolve","reject","timeoutID","setTimeout","abort","after","next","res","clearTimeout","then","defaults","headers","throwHttpErrors","credentials","transformSearchParams","p","HTTP","options","opts","resource","TypeError","base","startsWith","endsWith","url","searchParams","search","json","body","JSON","stringify","set","signal","ok","handleError","iterator","it","streamToAsyncIterator","isAsyncIterator","ndjson","chunk","transform","post","method","get","put","delete","source","decoder","buf","decode","stream","lines","split","i","length","l","trim","parse","Object","prototype","hasOwnProperty","call","iter","Symbol","asyncIterator","wrapper","return","destroy","reader","getReader","read","releaseLock","obj","module","exports"],"sources":["/Users/lalit/Documents/BlockChain Development/blockchainEcommerce/client/node_modules/ipfs-utils/src/http.js"],"sourcesContent":["/* eslint-disable no-undef */\n'use strict'\n\nconst fetch = require('node-fetch')\nconst merge = require('merge-options').bind({ ignoreUndefined: true })\nconst { URL, URLSearchParams } = require('iso-url')\nconst TextDecoder = require('./text-decoder')\nconst AbortController = require('abort-controller')\nconst anySignal = require('any-signal')\n\nconst Request = fetch.Request\nconst Headers = fetch.Headers\n\nclass TimeoutError extends Error {\n  constructor () {\n    super('Request timed out')\n    this.name = 'TimeoutError'\n  }\n}\n\nclass HTTPError extends Error {\n  constructor (response) {\n    super(response.statusText)\n    this.name = 'HTTPError'\n    this.response = response\n  }\n}\n\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise\n  }\n\n  const start = Date.now()\n\n  const timedOut = () => {\n    const time = Date.now() - start\n\n    return time >= ms\n  }\n\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError())\n        abortController.abort()\n      }\n    }, ms)\n\n    const after = (next) => {\n      return (res) => {\n        clearTimeout(timeoutID)\n\n        if (timedOut()) {\n          reject(new TimeoutError())\n          return\n        }\n\n        next(res)\n      }\n    }\n\n    promise\n      .then(after(resolve), after(reject))\n  })\n}\n\nconst defaults = {\n  headers: {},\n  throwHttpErrors: true,\n  credentials: 'same-origin',\n  transformSearchParams: p => p\n}\n\n/**\n * @typedef {Object} APIOptions - creates a new type named 'SpecialType'\n * @prop {any} [body] - Request body\n * @prop {Object} [json] - JSON shortcut\n * @prop {string} [method] - GET, POST, PUT, DELETE, etc.\n * @prop {string} [base] - The base URL to use in case url is a relative URL\n * @prop {Headers|Record<string, string>} [headers] - Request header.\n * @prop {number} [timeout] - Amount of time until request should timeout in ms.\n * @prop {AbortSignal} [signal] - Signal to abort the request.\n * @prop {URLSearchParams|Object} [searchParams] - URL search param.\n * @prop {string} [credentials]\n * @prop {boolean} [throwHttpErrors]\n * @prop {function(URLSearchParams): URLSearchParams } [transformSearchParams]\n * @prop {function(any): any} [transform] - When iterating the response body, transform each chunk with this function.\n * @prop {function(Response): Promise<void>} [handleError] - Handle errors\n */\n\nclass HTTP {\n  /**\n   *\n   * @param {APIOptions} options\n   */\n  constructor (options = {}) {\n    /** @type {APIOptions} */\n    this.opts = merge(defaults, options)\n  }\n\n  /**\n   * Fetch\n   *\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n  async fetch (resource, options = {}) {\n    /** @type {APIOptions} */\n    const opts = merge(this.opts, options)\n    opts.headers = new Headers(opts.headers)\n\n    // validate resource type\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request')\n    }\n\n    // validate resource format and normalize with prefixUrl\n    if (opts.base && typeof opts.base === 'string' && typeof resource === 'string') {\n      if (resource.startsWith('/')) {\n        throw new Error('`resource` must not begin with a slash when using `base`')\n      }\n\n      if (!opts.base.endsWith('/')) {\n        opts.base += '/'\n      }\n\n      resource = opts.base + resource\n    }\n\n    // TODO: try to remove the logic above or fix URL instance input without trailing '/'\n    const url = new URL(resource, opts.base)\n\n    if (opts.searchParams) {\n      url.search = opts.transformSearchParams(new URLSearchParams(opts.searchParams))\n    }\n\n    if (opts.json !== undefined) {\n      opts.body = JSON.stringify(opts.json)\n      opts.headers.set('content-type', 'application/json')\n    }\n\n    const abortController = new AbortController()\n    const signal = anySignal([abortController.signal, opts.signal])\n\n    const response = await timeout(fetch(url, {\n      ...opts,\n      signal,\n      timeout: undefined\n    }), opts.timeout, abortController)\n\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response)\n      }\n      throw new HTTPError(response)\n    }\n\n    response.iterator = function () {\n      const it = streamToAsyncIterator(response.body)\n\n      if (!isAsyncIterator(it)) {\n        throw new Error('Can\\'t convert fetch body into a Async Iterator:')\n      }\n\n      return it\n    }\n\n    response.ndjson = async function * () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk)\n        } else {\n          yield chunk\n        }\n      }\n    }\n\n    return response\n  }\n\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n  post (resource, options = {}) {\n    return this.fetch(resource, {\n      ...options,\n      method: 'POST'\n    })\n  }\n\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n  get (resource, options = {}) {\n    return this.fetch(resource, {\n      ...options,\n      method: 'GET'\n    })\n  }\n\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n  put (resource, options = {}) {\n    return this.fetch(resource, {\n      ...options,\n      method: 'PUT'\n    })\n  }\n\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n  delete (resource, options = {}) {\n    return this.fetch(resource, {\n      ...options,\n      method: 'DELETE'\n    })\n  }\n\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n  options (resource, options = {}) {\n    return this.fetch(resource, {\n      ...options,\n      method: 'OPTIONS'\n    })\n  }\n}\n\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncGenerator<Uint8Array, void, any>} source\n * @returns {AsyncGenerator<Object, void, any>}\n */\nconst ndjson = async function * (source) {\n  const decoder = new TextDecoder()\n  let buf = ''\n\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, { stream: true })\n    const lines = buf.split(/\\r?\\n/)\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim()\n      if (l.length > 0) {\n        yield JSON.parse(l)\n      }\n    }\n    buf = lines[lines.length - 1]\n  }\n  buf += decoder.decode()\n  buf = buf.trim()\n  if (buf.length !== 0) {\n    yield JSON.parse(buf)\n  }\n}\n\nconst streamToAsyncIterator = function (source) {\n  if (isAsyncIterator(source)) {\n    // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n    if (Object.prototype.hasOwnProperty.call(source, 'readable') && Object.prototype.hasOwnProperty.call(source, 'writable')) {\n      const iter = source[Symbol.asyncIterator]()\n\n      const wrapper = {\n        next: iter.next.bind(iter),\n        return: () => {\n          source.destroy()\n\n          return iter.return()\n        },\n        [Symbol.asyncIterator]: () => {\n          return wrapper\n        }\n      }\n\n      return wrapper\n    }\n\n    return source\n  }\n\n  const reader = source.getReader()\n\n  return {\n    next () {\n      return reader.read()\n    },\n    return () {\n      reader.releaseLock()\n      return {}\n    },\n    [Symbol.asyncIterator] () {\n      return this\n    }\n  }\n}\n\nconst isAsyncIterator = (obj) => {\n  return typeof obj === 'object' &&\n  obj !== null &&\n  // typeof obj.next === 'function' &&\n  typeof obj[Symbol.asyncIterator] === 'function'\n}\n\nHTTP.HTTPError = HTTPError\nHTTP.TimeoutError = TimeoutError\nHTTP.streamToAsyncIterator = streamToAsyncIterator\n\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options)\n\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options)\n\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options)\n\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options)\n\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options)\n\nmodule.exports = HTTP\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}